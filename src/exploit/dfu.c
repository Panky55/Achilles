#include <exploit/dfu.h>

// ******************************************************
// Function: isSerialNumberPwned()
//
// Purpose: Checks if the device is in pwned DFU mode using the serial number
//
// Parameters:
//      char *serialNumber: the serial number of the device
//
// Returns:
//      int: 0 if the device is in pwned DFU mode, 1 otherwise
//
// TODO: Deprecate this function
// ******************************************************
bool isSerialNumberPwned(char *serialNumber)
{
    extern bool bootingPongoOS;
    return bootingPongoOS ? (strstr(serialNumber, "YOLO") != NULL) : (strstr(serialNumber, "PWND") != NULL);
}

// ******************************************************
// Function: isSerialNumberPwned()
//
// Purpose: Checks if the device is in pwned DFU mode using the serial number
//
// Parameters:
//      char *serialNumber: the serial number of the device
//
// Returns:
//      int: 0 if the device is in pwned DFU mode, 1 otherwise
//
// TODO: Deprecate this function
// ******************************************************
bool isInDownloadMode(char *serialNumber)
{
    return strstr(serialNumber, "YOLO") != NULL;
}

// ******************************************************
// Function: isDFUSerialPwned()
//
// Purpose: Checks if the device is in pwned DFU mode
//
// Parameters:
//      dfu_serial_t serial: the serial number of the device
//
// Returns:
//      int: 0 if the device is in pwned DFU mode, 1 otherwise
// ******************************************************
int isDFUSerialPwned(dfu_serial_t serial)
{
    if (serial.pwnd[0] == '\0') {
        return 1;
    }
    return 0;
}

// ******************************************************
// Function: isSupported()
//
// Purpose: Checks if the device is supported by the checkm8 exploit
//
// Parameters:
//      int cpid: the cpid of the device
//
// Returns:
//      int: 0 if the device is supported, 1 otherwise
// ******************************************************
bool isSupported(int cpid)
{
    if (
        cpid == 0x8960 || cpid == 0x7000 || cpid == 0x7001 || cpid == 0x8000 
        || cpid == 0x8001 || cpid == 0x8003 || cpid == 0x8010 || cpid == 0x8011
        || cpid == 0x8012 || cpid == 0x8015
    )
        return true;
    return false;
}

// ******************************************************
// Function: DFUCheckStatus()
//
// Purpose: Checks the status of the device
//
// Parameters:
//      usb_handle_t *handle: the usb handle of the device
//      uint8_t status: the status of the device
//      uint8_t state: the state of the device
//
// Returns:
//      bool: true if the status and state match, false otherwise
// ******************************************************
bool DFUCheckStatus(const usb_handle_t *handle, uint8_t status, uint8_t state) {
	struct {
		uint8_t status, poll_timeout[3], state, str_idx;
	} dfu_status;
	transfer_ret_t transfer_ret;

	return sendUSBControlRequest(handle, 0xA1, DFU_GETSTATUS, 0, 0, &dfu_status, sizeof(dfu_status), &transfer_ret) && transfer_ret.ret == USB_TRANSFER_OK && transfer_ret.sz == sizeof(dfu_status) && dfu_status.status == status && dfu_status.state == state;
}

// ******************************************************
// Function: DFUSetStateWaitReset()
//
// Purpose: Get DFU into a state where it is awaiting a reset
//
// Parameters:
//      usb_handle_t *handle: the usb handle of the device
//
// Returns:
//      bool: true if the device changes to the correct state, false otherwise
// ******************************************************
bool DFUSetStateWaitReset(const usb_handle_t *handle) {
	transfer_ret_t transfer_ret;

	return sendUSBControlRequestNoData(handle, 0x21, DFU_DNLOAD, 0, 0, 0, &transfer_ret) && transfer_ret.ret == USB_TRANSFER_OK && transfer_ret.sz == 0 && DFUCheckStatus(handle, DFU_STATUS_OK, DFU_STATE_MANIFEST_SYNC) && DFUCheckStatus(handle, DFU_STATUS_OK, DFU_STATE_MANIFEST) && DFUCheckStatus(handle, DFU_STATUS_OK, DFU_STATE_MANIFEST_WAIT_RESET);
}